% -*- Mode: LaTeX; TeX-PDF-mode: t -*-
\documentclass{article}
\usepackage{amsmath,proof,amsthm,listings,algorithm}
\usepackage[noend]{algorithmic}
\renewcommand\algorithmiccomment[1]{ {\tt /*} #1 {\tt */}}
\newcommand\paren[1]{\left( {#1} \right)}
\newcommand\set[1]{\left\{ {#1} \right\}}
\newcommand\len[1]{\left| {#1} \right|}
% \newcommand\sched{\overset{s}{\mapsto}}
% \newcommand\wake[1]{\overset{w_{#1}}{\mapsto}}
\newcommand\sched{\xrightarrow{s}}
\newcommand\msched{\sched^{\!{\raisebox{-1.5ex}{*}}}}
\newcommand\wake[1]{\xrightarrow{w_{#1}}}
\newcommand\vcpu[1]{\paren{#1}}
\newcommand\pcpu[1]{\paren{#1}}
\newcommand\running[1]{\ensuremath{{running}\paren{#1}}}
\newcommand\runnable[1]{\ensuremath{{runnable}\paren{#1}}}
\newtheorem{thm}{Theorem}
\newtheorem{lma}{Lemma}
\newtheorem{prop}{Property}
% \numberwithin{equation}{subsection}
% \renewcommand{\theequation}{\thesubsection\arabic{equation}}
\lstset{language=C}

\begin{document}

\paragraph{Terminology} $\tau$ denotes a task, $Q$ denotes the quantum
(in time units), $n$ denotes remaining time, $\sched$ denotes {\tt
  schedule}, and $\wake{\tau}$ denotes {\tt wakeup} on task $\tau$.
VCPUs are represented as a tuple $\vcpu{\tau, n, \tau, \ldots}$
containing the current task, the remaining quantum, and the tasks in
the runqueue.  For convenience, assume that the runqueue entries are
filled with the idle task $\tau_0$ whenever needed.  VCPUs are denoted
with $V$.  $V_{\tau}$ is the VCPU associated with task $\tau$.  $0$
denotes idle or empty activity.  PCPUs are represented as a tuple
$\pcpu{V, V', \ldots}$ where $V$ is the current VCPU and $V',\ldots$
are in the VCPU queue.

\section{Round-Robin/Round-Robin Scheduling}

\subsection{First level scheduling}

\begin{subequations}
  \begin{equation}
    \label{pcpu:s1}
    \infer{\pcpu{V,V',\ldots}\sched\pcpu{V'',\ldots}}{
      V'\sched V'' & V''=(\tau, n, 0)
    }
  \end{equation}
  \begin{equation}
    \label{pcpu:s2}
    \infer{\pcpu{V,V',\ldots}\sched\pcpu{V'',V'',\ldots}}{
      V'\sched V'' & V''=(\tau, n, \tau', \ldots)
    }
  \end{equation}
  \begin{equation}
    \label{pcpu:s3}
    \infer{\pcpu{V,0}\sched\pcpu{0,0}}{}
  \end{equation}
  \begin{equation}
    \label{pcpu:w1}
    \infer{\pcpu{V,\ldots}\wake{\tau}\pcpu{V,\ldots,V'_{\tau}}}{
      V_{\tau}\wake{\tau}V'_{\tau} & V_{\tau} \not\in \set{\ldots}
    }
  \end{equation}
  \begin{equation}
    \label{pcpu:w2}
    \infer{\pcpu{V,\ldots,V_{\tau},\ldots}\wake{\tau}\pcpu{V,\ldots,V'_{\tau},\ldots}}{
      V_{\tau}\wake{\tau}V'_{\tau} &
    }
  \end{equation}
\end{subequations}
Rule~\ref{pcpu:s1} takes a VCPU $V'$ off the queue, transitions it to
$V''$ (with an empty runqueue) and then makes it the current VCPU.
Rule~\ref{pcpu:s2} applies when the VCPU has a non-empty runqueue.
Rule~\ref{pcpu:s3} handles the empty queue case.  Rule~\ref{pcpu:w1}
shows that both the task and the VCPU are placed on their respective
queues during wakeup, and rule~\ref{pcpu:w2} indicates idempotency of
VCPU {\tt wakeup}.

\subsection{Second level scheduling}

\begin{subequations}
  \begin{flalign}
    \vcpu{\tau, 0, \tau', \ldots} &\sched \vcpu{\tau', Q, \ldots} \label{vcpu:s1}\\
    \vcpu{\tau, n, \ldots, \tau, \ldots} &\sched \vcpu{\tau, n, \ldots}\quad\text{where }n > 0 \label{vcpu:s2}\\
    \vcpu{\tau, n, \tau', \ldots} &\sched \vcpu{\tau', n, \ldots}\quad\text{where }n > 0, \tau\neq\tau' \label{vcpu:s3}\\
    \vcpu{\tau, n, \ldots} &\wake{\tau'} \vcpu{\tau, n, \ldots, \tau'}\quad\text{where }\tau'\not\in\set{\ldots}\label{vcpu:w1} \\
    \vcpu{\tau, n, \ldots, \tau', \ldots} &\wake{\tau'} \vcpu{\tau,
      n, \ldots, \tau', \ldots} \label{vcpu:w2}
  \end{flalign}
\end{subequations}

Transition~\ref{vcpu:s1} occurs when the quantum expires.
Transition~\ref{vcpu:s2} occurs when the quantum has not expired and
the current task also appears on the runqueue.
Transition~\ref{vcpu:s3} is the remaining case for when the quantum
has not expired but the task is not runnable.
Transition~\ref{vcpu:w1} shows how tasks are added to the runqueue.
Transition~\ref{vcpu:w2} indicates idempotency of task {\tt wakeup}.

\section{Properties}

\begin{prop}
  \begin{subequations}
    \begin{equation}
      \label{eq:runningP}
      \infer{\running{\tau,(V,\ldots)}}{\running{\tau,V}}
    \end{equation}
    \begin{equation}
      \label{eq:runningV}
      \infer{\running{\tau,(\tau',n,\ldots)}}{\tau=\tau'}
    \end{equation}
  \end{subequations}
\end{prop}
\begin{prop}
  \begin{subequations}
    \begin{equation}
      \label{eq:runnableP}
      \infer{\runnable{\tau,(V,V_1,V_2,\ldots,V_m)}}{
        \exists_{j\in\set{1,\ldots,m}}\runnable{\tau,V_j}
      }
    \end{equation}
    \begin{equation}
      \label{eq:runnableV}
      \infer{\runnable{\tau,(\tau',n,\ldots,\tau'',\ldots)}}{\tau=\tau''}
    \end{equation}
  \end{subequations}
\end{prop}

\begin{prop}[Multiple step {\tt schedule}]
  \begin{subequations}
    \begin{equation}
      \label{msched:refl}
      \infer{P\msched P}{}
    \end{equation}
    \begin{equation}
      \label{msched:trans}
      \infer{P\msched P''}{P\sched P' & P'\msched P''}
    \end{equation}
  \end{subequations}
\end{prop}

\begin{lma}\label{lma:wakerun}
  If $P\wake{\tau} P'$ then \runnable{\tau,P'}.
\end{lma}
\begin{proof}
  Inversion on rules (\ref{pcpu:w1}) or (\ref{pcpu:w2}) gives
  $V_{\tau}\wake{\tau}V'_{\tau}$ and
  $P'=\pcpu{V,\ldots,V'_{\tau},\ldots}$.  Inversion on
  $V_{\tau}\wake{\tau}V'_{\tau}$ by (\ref{vcpu:w1}) or (\ref{vcpu:w2})
  says that $V'_{\tau}=\vcpu{\tau',n,\ldots,\tau,\ldots}$.  Therefore,
  \[
  \infer{\runnable{\tau, P'}}{
    \infer{\runnable{\tau,\pcpu{V,\ldots,V'_{\tau},\ldots}}}{
      \infer{\runnable{\tau,V'_{\tau}}}{
        \infer{\runnable{\tau,(\tau',n,\ldots,\tau,\ldots)}}{\tau=\tau}
      }
    }
  }
  \]
\end{proof}

\begin{lma}\label{lma:preservV}
  If \runnable{\tau,V} and $V\sched V'$ then either \runnable{\tau,V'}
  or \running {\tau,V'}.
\end{lma}
\begin{proof}
  In the case of rule~(\ref{vcpu:s1}) or rule~(\ref{vcpu:s3}), if
  $\tau$ is first on queue then it will start running.  If $\tau$ is
  not first in queue, then it remains runnable.

  In the case of rule~(\ref{vcpu:s2}), if $\tau$ is currently running
  then it will continue running.  If $\tau$ is on queue but not
  running, it will remain runnable.
\end{proof}

\begin{thm}[Preservation]\label{thm:preserv}
  If \runnable{\tau,P} and $P\sched P'$ then either \runnable{\tau,P'}
  or \running{\tau, P'}.
\end{thm}
\begin{proof}
  Consider the case of rule~(\ref{pcpu:s1})
  \begin{equation*}
    \infer{\pcpu{V,V',\ldots}\sched\pcpu{V'',\ldots}}{
      V'\sched V'' & V''=(\tau, n, 0)
    }
  \end{equation*}
  If $V_{\tau}\neq V'$ then it is still on queue and still runnable.
  Suppose instead that $V_{\tau}=V'$, then by lemma~\ref{lma:preservV}
  we know that either \runnable{\tau,V''} or \running{\tau,V''}.  But
  since $V''=\vcpu{\tau,n,0}$ we know $V''$ has an empty runqueue,
  therefore it must be the case that we have $\running{\tau,V''}$
  which implies $\running{\tau,P'}$.

  The other possible case is rule~(\ref{pcpu:s2})
  \begin{equation*}
    \infer{\pcpu{V,V',\ldots}\sched\pcpu{V'',V'',\ldots}}{
      V'\sched V'' & V''=(\tau, n, \tau', \ldots)
    }
  \end{equation*}
  This case is similar to the previous one except that $V''$ does not
  have an empty runqueue.  Therefore we must consider the subcase when
  $\runnable{\tau,V''}$.  Since $V''$ appears on the queue of $P'$,
  property~(\ref{eq:runnableP}) applies and \runnable{\tau,P'} can be derived.
\end{proof}

\newcommand\metric[1]{\ensuremath{\text{metric}\paren{#1}}}
\renewcommand\bar\overline
\begin{prop}[Induction Metric]
  The size of a VCPU is the length of its queue.
  \begin{equation}
    \label{eq:metric}
    \metric{(\tau,n,\bar\tau)}={\len{\bar\tau}}
  \end{equation}
  The size of a PCPU is double the number of VCPUs in the queue, plus
  the active VPCU if any.
  \begin{equation}
    \label{eq:metricV}
    \metric{(V,\bar V)}=2\sum_{v\in\bar V}{\metric{v}}+\len V
  \end{equation}
  The metric on a PCPU is the sum of the metrics on each queued VCPU,
  plus one if the PCPU is not idle.  Notably,
  $\metric{(0,0)}=0$, in other words, the idle PCPU is the lowest
  metric.
\end{prop}

\begin{lma}\label{lma:nonzerometricV}
  If $V\wake{\tau'}V'$ then $\metric {V'}>0$.
\end{lma}
\begin{proof}
  In the case of rule~(\ref{vcpu:w1}) the VCPU transition is
  $\vcpu{\tau,n,\ldots}\wake{\tau'}\vcpu{\tau,n,\ldots,\tau'}$,
  therefore the number of queued tasks is non-zero.  In the case of
  rule~(\ref{vcpu:w2}) the transition is
  $\vcpu{\tau,n,\ldots,\tau',\ldots}\wake{\tau'}\vcpu{\tau,n,\ldots,\tau',\ldots}$
  and the task is already queued, therefore the metric is unchanged,
  and cannot be zero.
\end{proof}

\begin{lma}\label{lma:nonzerometric}
  If a VCPU is on a PCPU queue then it has non-zero metric.
\end{lma}
\begin{proof}
  The only way a VCPU can arrive on a PCPU queue is through
  rules~(\ref{pcpu:w1}) or (\ref{pcpu:w2}), both of which require a
  derivation of $V\wake{\tau'}V'$, and by
  lemma~\ref{lma:nonzerometricV} this means $\metric{V'}>0$.
\end{proof}

\begin{lma}
  \label{lma:indstepV}
  If $V\sched V'$ then $\metric{V'}<\metric{V}$.
\end{lma}
\begin{proof}
  In all three rules (\ref{vcpu:s1}), (\ref{vcpu:s2}), and
  (\ref{vcpu:s3}), the length of the queue is reduced by one,
  therefore, $\metric{V'}<\metric{V}$.
\end{proof}

\begin{lma}\label{lma:indstep}
  If $P\sched P'$ then $\metric{P'}<\metric{P}$.
\end{lma}
\begin{proof}
  First consider rule~(\ref{pcpu:s1}) where
  $\pcpu{V,V',\ldots}\sched\pcpu{V'',\ldots}$.  Working backwards,
  \begin{flalign*}
    \metric{\pcpu{V'',\ldots}} &< \metric{\pcpu{V,V',\ldots}} \\
    2\paren{\cdots} + 1 &< 2\paren{\metric{V'}+\cdots}+\len V \\
    1 &< 2\cdot\metric{V'} + \len V
  \end{flalign*}
  since by lemma~\ref{lma:nonzerometric}, $\metric{V'}>0$, this
  inequality is true regardless of $\len V$.

  The next rule is (\ref{pcpu:s2}) where
  $\pcpu{V,V',\ldots}\sched\pcpu{V'',V'',\ldots}$.  By inversion we
  find that $V'\sched V''$ and $V''=\vcpu{\tau,n,\tau',\ldots}$.
  Using lemma~\ref{lma:indstepV} we know that $\metric{V''}<\metric{V'}$.
  Working backwards,
  \begin{flalign*}
    \metric{\pcpu{V'',V'',\ldots}} &< \metric{\pcpu{V,V',\ldots}} \\
    2\paren{\metric{V''}+\cdots} + 1 &< 2\paren{\metric{V'}+\cdots}+\len V \\
    2\cdot\metric{V''} + 1 &< 2\cdot\metric{V'} + \len V
  \end{flalign*}
  Since $\metric{V''}<\metric{V'}$, this inequality is always true even
  if $\len V=0$.

  Finally, rule~(\ref{pcpu:s3}) where $\pcpu{V,0}\sched\pcpu{0,0}$
  leads to $\metric{\pcpu{0,0}}<\metric{\pcpu{V,0}}$ which unfolds
  into $0<1$.
\end{proof}

\begin{thm}[Exhaustion]\label{thm:exhaust}
  $P\msched (0,0)$
\end{thm}
\begin{proof}[Proof by induction on \metric{P}]
  The base case where $\metric{P}=0$ implies $P=(0,0)$ and by
  property~(\ref{msched:refl}) you have $(0,0)\msched (0,0)$.  The
  interesting property is (\ref{msched:trans}).  By inversion,
  $P\sched P'$ and $P'\msched P''$.  By lemma~\ref{lma:indstep},
  $\metric{P'}<\metric{P}$.  Therefore, by induction, $P'\msched
  (0,0)$.  Using property~(\ref{msched:trans}) and $P\sched P'$, we
  arrive at $P\msched (0,0)$.
\end{proof}

\newpage
\section{VCPU}

%\begin{lstlisting}[gobble=2,float,caption={\tt schedule},label={lst:schedule}]
%\end{lstlisting}

A VCPU $V$, for the purposes of this algorithm, consists of budget
$V_b$, period $V_T$, replenishments $V_R$, current usage $V_u$, and
most recent activation time $V_a$.  Assume $\text{IDLE}_T=\infty$.
IO-VCPUs have eligibility time $V_e$, utilization $V_U$, a single
replenishment $V_r$, and boolean status of ``budgeted''.  $C_{max}$ is
defined as $V_T\cdot V_U$ for a given IO-VCPU.  A replenishment $r$ is
a pair consisting of a time $r_t$ and some amount of budget $r_b$.

The scheduler relies on four VCPU-specific functions: {\tt
  end-of-timeslice}, {\tt update-budget}, {\tt next-event}, and {\tt
  unblock}.  The first three are used by algorithm~\ref{alg:schedule}.
The wakeup routine invokes {\tt unblock}.

\begin{algorithm}
  \caption{\tt schedule}\label{alg:schedule}
  \begin{algorithmic}[1]
    \REQUIRE $V$ is current VCPU.
    \REQUIRE $\bar V$ is set of runnable VCPUs.
    \REQUIRE $t_{cur}$ is current time.
    \REQUIRE $t_{prev}$ is previous time of scheduling.

    \STATE Let $\Delta t=t_{cur}-t_{prev}$ and let $T_{prev}=V_T$.
    \STATE Invoke {\tt end-of-timeslice} on $V$ with $\Delta t$.

    \STATE Find $V_{next}\in\bar V$ with the highest priority and
    non-zero budget.  Invoke {\tt update-budget} on each VCPU you 
    consider before checking its budget.

    \IF{there is no satisfactory $V_{next}$}
    \STATE Enter idle mode and go to step~\ref{sched:repltimer}.
    \ENDIF

    \STATE Let $T_{next}$ be the period of $V_{next}$.

    \STATE Internally schedule $V_{next}$.
    \IF{$V_{next}$ has empty runqueue}
    \STATE Let $\bar V'=\bar V\setminus\set{V_{next}}$
    \STATE $V_{next}$ is no longer runnable.
    \ELSE
    \STATE Let $\bar V'=\bar V$.
    \ENDIF

    \STATE Initially let $\Delta t'$ be equal to the budget of $V_{next}$.
    \FOR{\label{sched:repltimer}each VCPU $v\in\bar V$ with higher priority than $V_{next}$}
    \STATE Let $t_e$ be the result of {\tt next-event} on $v$.
    \IF{$t_e$ is valid \AND $t_e-t_{cur}<\Delta t'$}\STATE Set $\Delta t':=t_e-t_{cur}$.\ENDIF
    \ENDFOR
    \STATE Set timer to go off after $\Delta t'$ has elapsed.
    \STATE Set $t_{prev}:=t_{cur}$ for next time.
    \STATE Switch to $V_{next}$ or idle.
    \ENSURE $\bar V'$ is now the set of runnable VCPUs.
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{\tt MAIN-VCPU-end-of-timeslice}\label{alg:vcpu_eot}    
  \begin{algorithmic}[1]
    \REQUIRE VCPU $V$
    \REQUIRE Time interval consumed $\Delta t$
    \STATE Set $V_u:=V_u+\Delta t$.
    \STATE Invoke {\tt budget-check} on $V$.
    \IF[Blocked or preempted]{$capacity(V)>0$}
    \IF[Blocked]{$V$ is \NOT runnable}
    \STATE Invoke {\tt split-check} on $V$.
    \ENDIF
    \STATE Set $V_b:=capacity(V)$.
    \ELSE
    \STATE Set $V_b:=0$.
    \ENDIF
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{\tt MAIN-VCPU-update-budget}\label{alg:vcpu_upbudg}
  \begin{algorithmic}[1]
    \REQUIRE VCPU $V$
    \REQUIRE Current time $t_{cur}$
    \STATE Set $V_b:=max\{capacity(V), 0\}$.
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{\tt MAIN-VCPU-next-event}\label{alg:vcpu_nextevent}
  \begin{algorithmic}[1]
    \REQUIRE VCPU $V$
    \REQUIRE Current time $t_{cur}$
    \RETURN $\min\{r_t \mid r\in V_R\wedge t_{cur}<r_t\}$ \OR ``No event.''
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{\tt IO-VCPU-unblock}\label{alg:iovcpu_unblock}
  \begin{algorithmic}[1]
    \REQUIRE IO VCPU $V$ associated with IO task.
    \REQUIRE Main VCPU $M$ waiting for result of IO task.
    \REQUIRE $t_{cur}$ is current time.
    \IF{$M_T<V_T$ \OR $V$ is \NOT running}
    \STATE Set $V_T:=M_T$.
    \ENDIF
    \IF{$V$ is \NOT running \AND $V_e<t_{cur}$}
    \STATE Set $V_e:=t_{cur}$.\COMMENT{IO-VCPU has been quiescent}
    \ENDIF
    \IF{$V_R=\emptyset$}
    \IF{$V$ is \NOT ``budgeted''}
    \STATE Post replenishment on $V$ for $C_{max}$ budget at time $V_e$.
    \ENDIF
    \ELSE
    \STATE There is $V_R=\{r\}$, set $r_b:=C_{max}$.
    \ENDIF
    \STATE Set $V$ as ``budgeted.''
    \STATE Invoke algorithm~\ref{alg:iovcpu_upbudg} {\tt update-budget} on $V$.
    \REQUIRE $CUR$ is currently running VCPU.
    \IF{$V_b>0$ \AND ($CUR$ is idle \OR $CUR_T>V_T$)}
    \STATE Preempt and invoke scheduler.
    \ENDIF
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{\tt IO-VCPU-end-of-timeslice}\label{alg:iovcpu_eot}
  \begin{algorithmic}[1]
    \REQUIRE VCPU $V$
    \REQUIRE Time interval consumed $\Delta t$
    \STATE Set $V_b:=\max\{0,V_b-\Delta t\}$.
    \STATE Set $V_u:=V_u+\Delta t$.
    \IF[Blocked or budget exhausted]{$V$ is \NOT runnable \OR $V_b=0$}
    \STATE Set $V_e:=V_e+V_u/V_U$.
    \IF{$V_r$ is unused}
    \STATE Set $V_r:=r$ where $r_t=V_e$ and $r_b=C_{max}$.
    \ELSE
    \STATE Set $V_{r_t}:=V_e$.
    \ENDIF
    \STATE Set $V_u:=0$.
    \IF{$V$ is runnable}
    \STATE Set $V_b:=0$.
    \ELSE
    \STATE Set $V$ as \NOT ``budgeted.''
    \ENDIF
    \ENDIF
    \ENSURE $0\leq V_b\leq C_{max}$
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{\tt IO-VCPU-update-budget}\label{alg:iovcpu_upbudg}
  \begin{algorithmic}[1]
    \REQUIRE VCPU $V$
    \REQUIRE Current time $t_{cur}$
    \IF{$V_r$ is valid \AND $V_{r_t}\leq t_{cur}$}
    \STATE Set $V_b:=V_{r_b}$.
    \STATE Invalidate $V_r$.
    \ENDIF
    \ENSURE $0\leq V_b\leq C_{max}$
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{\tt IO-VCPU-next-event}\label{alg:iovcpu_nextevent}
  \begin{algorithmic}[1]
    \REQUIRE VCPU $V$
    \REQUIRE Current time $t_{cur}$
    \IF{$V_r$ is valid \AND $t_{cur}<V_{r_t}$}
    \RETURN $V_{r_t}$.
    \ELSE
    \RETURN No event.
    \ENDIF
  \end{algorithmic}
\end{algorithm}

\end{document}
